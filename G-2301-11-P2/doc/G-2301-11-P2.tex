\documentclass{article}

\renewcommand*\familydefault{\sfdefault}

\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[left=3cm,right=2cm,top=3cm,bottom=2cm]{geometry} % Márgenes
\usepackage{imakeidx} % Creación de índices
\usepackage{titling} % No tengo claro para qué es esto
\usepackage{fancyhdr} % Cabeceras de página
\usepackage{lastpage} % Módulo para añadir una referencia a la última página
\usepackage[spanish,es-noquoting,es-noshorthands]{babel} % Cadenas de LaTeX traducidas al español 
\usepackage{amsthm} % Paquete de matemáticas
\usepackage{framed} % Marcos 
\usepackage{mdframed} % Más marcos
\usepackage{exmath} % Nuestro querido paquete de utilidades
\usepackage{hyperref} % Para que salgan enlaces en la tabla de contenidos y el glosario
\usepackage{wrapfig} % Figuras flotantes
\usepackage{MathUnicode} % Paquete para poder poner caracteres griegos y demás cosas raras.
\usepackage{listings} % Para poner código.
\usepackage{tikz}

\fancyhf{}
\PrerenderUnicode{ÁáÉéÍíÓóÚúÑñ} % Para que salgan las tildes y demás mierdas en el título.
\fancypagestyle{plain}{%
\lhead{} 
\rhead{} 
\cfoot{\thepage\ de \pageref{LastPage}}
}

% Números en las subsecciones
\setcounter{secnumdepth}{3}

% Ajustes para los enlaces
\hypersetup{
	hyperindex,
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

%%%%% Listings UTF8 %%%%%
\lstset{literate=%
{á}{{\'a}}1
{é}{{\'e}}1
{í}{{\'i}}1
{ó}{{\'o}}1
{ú}{{\'u}}1
{Á}{{\'A}}1
{É}{{\'E}}1
{Í}{{\'I}}1
{É}{{\'O}}1
{Ú}{{\'U}}1
}

\title{Práctica 2 Redes II - Grupo 2301 Pareja 11}
\author{Guillermo Julián Moreno y Víctor de Juan Sanz}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
En esta práctica se ha implementado con éxito un cliente IRC, siguiendo las especificaciones de los RFC 1459 y 2813, en lenguaje C. Hemos ido algo más allá de programar simplemente un ejercicio para entregar y hemos tratado de crear un sistema robusto, modular, con pruebas exhaustivas, con código limpio y fácil de mantener.

En este documento describimos a grandes rasgos la arquitectura e implementación del cliente. La documentación más exhaustiva a nivel de código se encuentra en los correspondientes ficheros de documentación en formato \textit{man}, \textit{\LaTeX} o \textit{html} generados por Doxygen.
\end{abstract}

\section{Arquitectura}

\subsection{Hilos}

\begin{figure}[hbtp]
\centering
\begin{tikzpicture}
\node[rectangle, draw, inner sep=10pt] (R) at (0,0) {Receiver};
\node[rectangle, draw, inner sep=10pt] (P) at (3,-2.5) {Processor};
\node[rectangle, draw, inner sep=10pt] (S) at (6,0) {Sender};
\node[rectangle, draw, inner sep=10pt] (G) at (-1.5, -3) {GUI};
\node[circle, draw, inner sep=7pt] (C) at (3,3) {Servidor};

\draw[->] (G) -- node[midway,above, sloped] {Comandos} node[midway,below, sloped]{de usuario} (P);
\draw[->] (C) -- node[midway,above,sloped] {Mensajes C <- S} (R);
\draw[->] (R) -- node[midway,above,sloped] {Mensajes} node[midway,below, sloped]{recibidos} (P);
\draw[->] (P) -- node[midway,above,sloped] {Mensajes} node[midway,below, sloped]{a enviar} (S);
\draw[->] (S) -- node[midway,right] {Mensajes C -> S} (C);
\end{tikzpicture}
\caption{Arquitectura de hilos del cliente.}
\label{imgHilos}
\end{figure}

Nuestro cliente funciona con 4 hilos distribuidos de la siguiente forma (figura \ref{imgHilos}):
\begin{itemize}
\item Un hilo que recibe los datos de esas conexiones (\emph{receiver}) y encola los mensajes recibidos mediante una cola de sistema con la que se comunica con el procesador. \textit{receiver} recibe a través de un socket local UNIX las nuevas conexiones que establezca \textit{listener}.
\item El hilo principal o \textit{processor}, que gestiona las estructuras de datos y realiza los cambios necesarios a partir de los comandos. Es el encargado de analizar los mensajes. Los mensajes generados como respuesta se encolarán hacia \textit{sender}.
\item El hilo que envía los mensajes (\emph{sender}). Recibe los mensajes encolados para enviarlos a través del socket correspondiente.
\item Un hilo dedicado a responder a la interfaz de usuario, enviando los mensajes que se reciban al procesador para actuar en consecuencia.
\end{itemize}

El hilo de procesado, \textit{processor}, usa colas XSI (\texttt{msgget}) para recibir los mensajes de \textit{receiver} y enviarlos a \textit{sender}. Para ello se utiliza la estructura \texttt{sockcomm\_data}, que contiene los datos necesarios para procesar el mensaje (socket de origen/destino, mensaje y su longitud). Esta estructura está encapsulada en otra, \texttt{msg\_sockcommdata}, para enviar los datos a través de las colas.

\paragraph{Justificación del diseño} Hemos decidido reutilizar prácticamente todo el código que teníamos en el servidor. El único cambio que hemos tenido que hacer en ese código ha sido un nuevo procesador que llamase a otras funciones en lugar de las de al servidor. Esto nos ha ahorrado mucho trabajo tanto de desarrollo como de depuración.

\subsection{Estructuras de datos}

En la estructura de datos globales del cliente de IRC (\texttt{irc\_clientdada}) simplemente mantenemos ciertos datos que queremos guardar del usuario, como el nick, el canal al que está conectado o los datos de la llamada en curso. El cliente IRC no requiere guardar más datos.

\subsection{Código}

Pasamos ahora a describir la estructura de nuestro código y los archivos más destacados

\begin{itemize}
\item \texttt{includes} Contiene todos los archivos \texttt{.h}.
\begin{itemize}
\item \texttt{types.h} Archivo con todos los tipos y estructuras fundamentales del servidor.
\item \texttt{errors.h} Códigos de error para la interpretación del valor de retorno de nuestras funciones.
\end{itemize}
\item \texttt{src} Contiene los archivos de código principales, incluyendo \texttt{main} y las funciones específicas de IRC.
\begin{itemize}
\item \texttt{irc\_funs\_server.c} Implementaciones de cada uno de los comandos de IRC del servidor.
\item \texttt{irc\_funs\_client.c} Implementaciones de cada uno de los comandos de IRC del cliente, recibidos del servidor.
\item \texttt{irc\_funs\_userinput.c} Implementaciones de cada uno de los comandos de IRC del cliente, recibidos a través de la interfaz de usuario.
\item \texttt{irc\_processor.c} Funciones auxiliares de manejo y procesado de mensajes IRC.
\end{itemize}
\item \texttt{srclib} Contiene las distintas librerías que usamos en el programa.

\begin{itemize}
\item \texttt{libcollections} Contiene \texttt{list} y \texttt{dictionary}, las dos colecciones que usamos en la práctica.
\item \texttt{libcommander} Contiene un intérprete de comandos general junto con un hilo de procesado.
\item \texttt{libjsmn} Una \href{http://zserge.bitbucket.org/jsmn.html}{librería de terceros} que incluye un analizador simple de JSON en pocas líneas de código y sin dependencias extra.
\item \texttt{libsockets} Todas las funciones necesarias para el manejo de socket, incluyendo los hilos de escucha, envío y recepción.
\item \texttt{libstrings} Funciones auxiliares relativas al manejo de cadenas.
\item \texttt{libsysutils} Utilidades del sistema.
\item \texttt{libircgui} Funciones de la interfaz de usuario.
\item \texttt{libsound} Funciones de audio.
\end{itemize}
\item \texttt{tests} Funciones de prueba.
\item \texttt{tools} Scripts y herramientas auxiliares.
\end{itemize}

Hemos tenido que modificar algunas funciones que se proveyeron para adaptarlas a nuestras necesidades, con cosas como la posibilidad de activar o desactivar botones según el usuario esté en un canal o no, o modificaciones de las de sonido para permitir incluir pruebas.

\section{Pruebas}
Hemos ido realizando test de las funciones que íbamos implementando y los hemos organizado en 3 niveles. 

\begin{itemize}
\item[1] \textbf{Test} Genera el ejecutable llamando a las \textit{suites}.
\item[2] \textbf{Suites} Colecciones de test para cada uno de los módulos, como los hilos o las funciones de IRC.
\item[3] Cada una de las \textit{suites} tiene funciones que van probando las funcionalidades del programa.
\end{itemize}

Cada una de las funciones de test tiene una nomenclatura común que hace más sencilla la identificación de fallos: \texttt{t\_[nombre de la función a probar]\_\_[situación que se prueba]\_\_[resultado esperado]}.

Estos test nos han permitido probar todas las funciones a medida que íbamos programando, sin esperar a conectar con el servidor. También nos ha permitido detectar regresiones, fallos que hemos introducido durante el desarrollo sin darnos cuenta, y corregirlos a tiempo. En total, nuestro servidor cuenta con 159 funciones de prueba.

Además de todas las pruebas automáticas y con varios servidores, hemos pasado regularmente el analizador estático de \textit{clang} para encontrar ciertos fallos en el código detectables antes de la ejecución, como uso de estructuras sin inicializar o uso después de liberar memoria.

\section{Uso}

El \textit{daemon} se arranca ejecutando el comando \texttt{bin/G-2301-11-P2-main}. Los logs se guardan en en el registro del sistema con el prefijo \textit{redirc}. En caso de querer parar el servidor, el comando \texttt{bin/G-2301-11-P2-main stop} cerrará el servidor ordenadamente.

El servidor lee parámetros de configuración del fichero \texttt{redirc.conf}. De momento los parámetros son únicamente la lista de operadores del servidor y sus contraseñas, en formato JSON no estricto.

El cliente se ejecuta con el comando \texttt{bin/chat}, sin argumentos.

Para ejecutar los tests, simplemente hay que ejecutar \texttt{bin/G-2301-11-P2-test}, y los resultados saldrán por pantalla. El ejecutable de pruebas tiene comandos adicionales para ejecutar sólo suites específicas (\texttt{include suite1 suite2 ...}) o excluirlas (\texttt{exclude suite1 suite2 ...}).

\subsection{Makefile}

Nuestro Makefile cuenta con varios objetivos que pasamos a comentar:

\begin{description}
\item[server] Compilación del servidor.
\item[chat]  Compilación del binario del cliente.
\item[prsound] Compilación del binario de pruebas de sonido.
\item[no-daemon] Compilación con la bandera \texttt{NODAEMON} definida que evita que el servidor se \textit{daemonice}. Especialmente útil a la hora de depurar con \textit{gdb/lldb} o ejecutar con \textit{valgrind}.
\item[clean] Limpieza de ficheros ejecutables, de compilación y documentación autogenerada.
\item[test] Compilación con banderas de depuración del ejecutable de pruebas.
\item[docs] Generación de manuales con \textit{doxygen} y compilación de documentos LaTeX (esta memoria y el manual de referencia de Doxygen). 
\item[docclean] Limpieza de la documentación generada automáticamente.
\item[pack] Renombrado de archivos para cumplir con las especificaciones del enunciado y empaquetado de la práctica.
\end{description}

\section{Llamadas}

Nuestra implementación de llamadas funciona para transmitir sonido entre dos usuarios entre los que no haya routers NAT. Para poder realizar la llamada, el usuario debe ejecutar el comando \textit{/pcall}, que envía un mensaje al destinatario con la IP del cliente (obtenida al registrarse en el servidor a través del comando \textit{WHO}) y el puerto en el que recibirá la llamada. El usuario llamado puede responder con \textit{/paccept} para iniciar la conexión o con \textit{/pclose} para rechazarla.

El módulo de llamadas se encarga, a través de tres hilos (grabación y envío, recepción y reproducción) de enviar paquetes de 20 ms de audio, reordenándolos en un buffer circular en caso de que lleguen desordenados y controlando el retardo para tratar de minimizar la latencia. 

El objetivo es que los paquetes se reproduzcan tan pronto lleguen. El módulo mide la latencia de comunicación a través del campo \textit{timestamp} del paquete RTP, y después calcula la latencia de reproducción usando la longitud del buffer circular y la función \texttt{pa\_simple\_get\_latency} de Pulseaudio. El módulo de llamadas descartará paquetes puntuales para reducir la latencia de reproducción sin que se aprecien cortes en la llamada y disminuir así la latencia de la llamada.

\section{Conclusiones}

Hemos reafirmado la conclusión de la práctica pasada, al haber tenido mucho menos trabajo gracias al haber programado de forma modular y con una documentación completa el código del servidor, que hemos podido reutilizar en su mayor parte.

También hemos visto que el hecho de implementar una interfaz de usuario en C presenta dificultades en ese propósito de crear funciones modulares. Tal y como está diseñada la API de GTK y las posibilidades de C no se pueden crear funciones que no dependan de la interfaz sin hacer. En tareas de este estilo habría sido más cómodo usar lenguajes más orientados a objetos y patrones como MVVM o MVC, en los que es la interfaz la que responde al cambio del estado y no al revés. En este caso nos ha sido más difícil realizar pruebas automáticas, ya que era muy difícil quitar las dependencias de GTK y sustituirlas por funciones que simplemente verifiquen que todo ha ido bien. 

\end{document}
